## 集合与数组的对比
- 长度
数组的长度是固定的,集合的长度是可变的
- 存储类型
数组既可以存基本类型,也可以存引用类型数据
集合可以存引用数据类型,需要存基本数据类型必须封装成包装类

List集合:添加元素有序,可重复,有索引
Set集合:添加的元素无序,不重复,无索引

### Collection
Collection是单列集合的祖宗接口,它的功能是全部单列集合都可以继承使用的
- ```public boolean add(E e)```:把给定的对象添加到当前集合中
- ```public void clear()```:清空集合中的所有对象
- ```public boolean remove(E e)```:把给定的对象从当前集合中删除
- ```public boolean contains(Object obj)```:判断当前集合是否包含给定的对象
- ```public boolean isEmpty()```:判断当前集合是否为空
- ```public int size()```:返回元素中的个数

### Collection的遍历方式
**迭代器遍历**:<br>
迭代器在java中的类是Iterator,迭代器是集合专用的遍历方式
- ```Iterator<E> iterator()```:返回迭代器对象,默认指向当前集合的0索引
- ```boolean hasNext()```:判断当前位置元素是否有元素,有元素返回true,否则返回false
- ```E next()```:获取当前位置的元素,并将迭代器对象移向下一位置
细节:
1. 报错NoSuchElementException
2. 迭代器遍历完毕,指针不会复位
3. 循环中每一次只能用一次next方法
4. 迭代器遍历时,不能用集合方法进行增加或者删除,可以使用迭代器方法进行删除,不能添加

**增强for遍历**:
- 增强for的底层就是迭代器,为了简化迭代器的代码书写的.
- 他是JDK5之后出现的,其内部原理就是一个Iterator迭代器
- 所有的单例集合和数组才能用增强for进行遍历
- 修改增强for中的变量,不会改变集合中原本的数据

**Lambda表达式遍历**:
```default void forEach(Consumer<? super T> action)```:结合Lambda遍历集合

总结:如果遍历过程中需要删除元素用迭代器遍历,否则用增强for或者Lambda表达式

### List集合特有方法
- Collection的方法List都继承了;
- List集合有索引,所以多了很多索引操作的方法<br>
方法:
- ```void add(int index, E element)```:在集合中的指定位置插入指定的元素
- ```E remove(int index)```:删除指定索引处元素,返回被删除的元素
- ```E set(int index, E element)```:修改指定索引处的元素,返回被修改的元素
- ```E get(int index)```:返回指定索引处的元素

List遍历方式:
1. 迭代器遍历
2. 增强for遍历
3. Lambda表达式遍历
4. 普通for遍历
5. 列表迭代器遍历:可以在迭代器遍历过程中添加和删除

### ArrayList底层原理
1. 利用空参创建的集合,在底层创建一个长度为0的数组
2. 添加第一个元素时,底层元素会创建一个新的长度为10的数组
3. 存满时,扩容1.5倍
4. 如果一次添加多个元素,1.5倍空间放不下,则新数组长度以实际为准

### LinkedList
- 底层是一个双向链表结构,查询慢,删除块,但是如果是操作首尾元素,速度极快<br>
方法:
- ```public void addFirst(E e)```:在列表开头插入指定元素
- ```public void addLast(E e)```:在列表末尾追加指定元素
- ```public E getFirst()```:返回列表第一个元素
- ```public E getLast()```:返回列表最后一个元素
- ```public E removeFirst()```:从列表中删除并返回第一个元素
- ```public E removeLast()```:从列表中删除并返回最后一个元素

### 泛型
作用:可以在编译阶段约束操作的数据类型,并进行检查.
- 泛型只能写引用数据类型
- 指定泛型的具体类型后,传递数据时,可以传入该类类型或者其子类型
- 如果不写泛型,默认类型为Object
- 写在类后边叫泛型类  方法后边叫泛型方法 接口后边叫泛型接口

使用场景:当一个类中,某个变量的数据类型不确定时,就可以定义带泛型的类
方法中形参不确定时:
1. 使用类定义泛型 所有方法都能用 ```public class ArrayList<E> {}```
2. 在方法上定义自己的泛型 只有笨方法可以使用 ```public <T> viod show(T t) {}```
3. 泛型接口 ```public interface List<E>{}```
> 此处E和T可以理解为变量,记录数据的类型

如何使用一个带泛型的接口:
1. 给出类的具体实现
2. 实现类延续泛型,创建对象在确定