# 面向对象

### 类和对象
类: 是对象共同特征的描述
对象:是真实存在的具体东西
在java中,必须要先设计类,才能获得对象

类名首字母建议大写,驼峰命名
java文件中可以定义多个类,但只能有一个是public修饰,而且public修饰的类名必须  称为代码文件名
实际开发中建议一个文件还是定义一个类
定义成员变量的完整格式: `修饰符 数据类型 变量名称 = 初始化值`;一般无需指定初始值,存在默认值

### 对象封装
- 对象代表什么,就封装什么样的数据,并提供数据对应的行为
private 关键字
- 是一个权限修饰符
- 可以修饰成员
- 被private修饰的成员只能在本类中才能访问
### this
就近原则
java中的this区分成员变量和局部变量

### this的本质和内存图

### 构造方法
构造方法也叫构造器和构造函数
作用是在创建对象时给成员变量赋值
特点:
1. 方法名和类名相同,大小写也一致
2. 没有返回类型,连void也没有
3. 没有具体返回值

执行时机:
1. 创建对象时由虚拟机调用,不能手动调用构造方法
2. 每创建一次对象,就会调用一次构造函数

- 如果没有定义构造方法,系统将给出一个默认的无参构造方法
- 如果定义了,系统将不再提供默认构造方法 
- 带参构造和无参构造,两者方法名相同,但是参数不同,叫做构造方法的重载
- 无论是否使用,都手动书写无参构造方法,和带全部参数的构造方法,保证对象后期可是使用性

### 标准的javaBean类
1. 类名需要见名知意
2. 成员变量使用private修饰
3. 提供至少两个方法
  - 无参数构造
  - 带全部参数构造
4. 成员方法:
  - 提供一个成员变量对应的setXXX()/setXXX()
  - 如果还有其它行为,也要写上
### 对象内存图
1. 加载class文件
2. 声明局部变量
3. 在堆内存中开辟一块空间
4. 默认初始化
5. 显示初始化
6. 构造方法初始化
7. 把堆内存中的地址值赋值给左边的局部变量

### this的内存原理
this的作用: 区分局部变量和成员变量
this的本质:代表方法调用者的地址值;
### 成员变量和局部变量
     区别                       成员变量                            局部变量
     类中的位置不同              类中,方法外                         方法内,方法声明上
     初始化值不同                有默认初始值                        没有默认初始值,使用之前需要赋值
     内存位置不同                堆内存                             栈内存
     生命周期不同                随着对象创建而存在,随着对象消失而消失 随着方法调用而存在,随着方法运行结束而消失
     作用域                     整个类中有效                        当前方法有效

### static注意事项
- 静态方法只能访问静态变量和静态方法
- 非静态方法可以访问静态变量或者静态方法,也可以访问非静态的成员变量和非静态的成员方法
- 静态方法是没有this关键字的
总结:
- 静态方法中只能访问静态
- 非静态方法中可以访问所有
- 静态方法中没有this关键字

### 继承
- java中提供了一个关键字extends, 用这个关键字,可以让一个类和另一个类建立起继承连接.
```java
public class Student extends Person {}
```
- Student称为子类, Person称为父类
好处:
- 可以把多个子类中重复的代码抽取到父类中,提高代码复用性
- 子类可以在父类基础上,增加其它功能,使子类更强大
特点:
- java只支持单继承,不支持多继承,但支持多层继承
- Java中所有类都直接或者间接继承于Object
注意:子类只能访问父类非私有的成员
继承中:成员变量的访问特点 就近原则:谁离我近,我就用谁    先在局部位置找--->本类成员位置查找 --->父类成员查找 
方法的重写:
- 当父类的方法不能满足子类现在的需求时就需要进行方法重写
- 通过@Overrid重写注释,校验子类重写语法是否正确

继承中方法的访问特点:
- 子类不能继承父类的构造方法,但是可以通过super调用
- 子类构造方法第一行,有一个默认的super()
- 默认先访问父类无参数的构造方法,再访问自己的
- 如果想要父类方法有参构造,必须手动手写

### this和super使用总结
this:理解为一个变量,表示当前调用者的地址值
super:代表父类存储空间

### 多态
同类型的对象,表现出的不同形态
多态的表现形式: 父类名称 对象名称 = 子类对象
多态的前提:
 - 有继承关系
 - 有父类引用指向子类对象
 - 有方法重写
好处:
 - 使用父类型作为参数,就可以接收所有子类对象

调用成员变量:编译看左边,运行也看左边:
 - 编译看左边:javac编译代码时,会看左边父类中有没有这个变量,如果有编译成功,没有则编译失败
 - 运行也看左边:java运行代码时,实际获取就是左边父类成员变量的值
调用成员方法:编译看左边,运行看右边
 - 编译看左边:javac编译代码时,会看父类中有没有这个方法,如果有编译成功,否则编译失败
 - 运行看右边:java运行代码时,实际上运行的是子类中的方法
   理解:
```Dog d = new Dog()```
 - d调用那么属性会先到Dog类里面去找, 找不到再到Animal父类中找是否有该属性
```Animal a = new Dog()```
 - 现在用a去调用变量和方法,而a是Animal类型,所以默认会从Animal这个类中找   同js中的作用域,全局不能访问局部变量,局部变量可以访问全局变量
 - 成员变量:在子类的对象中,会把父类的成员变量也继承下来, 父:name  子:name
 - 成员方法:如果子类对方法进行了重写,那么虚方法表中会把父类方法进行覆盖

多态的优势:
- 在多态形式下,左边的对象可以实现解耦合,便于扩展和维护
```
Person p = new Student;
p.work();// 业务逻辑发生改变时,后续代码无需修改
```
- 定义方法时,使用父类型作为参数,可以接收所有的子类对象,体现多态的扩张性与便利
多态的弊端:
- 不能直接调用子类的特有特征
解决方法:强制转换回子类类型
- ```Dog d = (Dog)a``` 


### 权限修饰符
- private(私有的) 同一个类中自己用
- 空着不写(默认) 同一个包中的其它类,只能在本包中使用
- protected(受保护的) 不同包下的子类
- public(公共的) 不同包下的无关类

使用规则:
- 一般只用private和public
  - 成员变量私有
  - 方法公开
> 特例:如果方法中的代码是抽取其它方法中共性代码,一般这个方法也私有

### 代码块
- 局部代码块(不常用)
- 构造代码块(不常用)
- 静态代码块(常用):需要通过static修饰 随着类的加载而加载,并且自动出发,只执行一次

### 抽象类和抽象方法
- 抽象方法:将共性的行为(方法)抽取到父类之后,由于每一个子类执行的内容是不一样,所以在父类不能确定具体方法题,该方法就是抽象方法;
- 如果一个类中存在抽象方法,那么该类就必须声明为抽象类;
抽象方法定义格式: ```public abstract 返回值类型 方法名(参数列表)```
抽象类和抽象方法注意事项:
- 抽象类不能实例化
- 抽象类不一定有抽象方法,有抽象方法的类一定是抽象类
- 抽象类可以有构造方法
- 抽象类的子类
  - 要么重写抽象类所有抽象方法
  - 要么本身也是一个抽象类
抽象方法的意义:
  - 规范代码格式,方便合作调用

### 接口
1. 接口代表规则,是行为的抽象,想让哪个类拥有一个行为,就让这个类实现对应的接口即可;
2. 当一个方法的参数是一个接口时,可以传递接口所有实现类的对象,这种方法叫做借口多态;

接口的定义和使用
- 接口用关键字interface定义 ```public interface 接口名 {}```
- 接口不能实例化
- 接口和类之间是实现关系,通过implements关键字表示 ```public class 类名 implement 接口名 {}```
- 接口的子类(实现类) 要么重写接口中所有抽象方法,要么是抽象类
注意:接口和类的关系可以单实现,也可以多实现 ```public class 类名 extends 父类 implement 接口名1, 接口名2{}```

接口中的成员特点
- 成员变量:只能是常量 默认修饰符```public static final```
- 构造方法(没有)
- 成员方法:可以定义有方法体的方法, JDK9:可以定义私有变量

接口和类之间的关系: 实现关系,可以单实现,也可以多实现,还可以继承一个类的同时实现多个接口
接口和接口之间的关系:继承关系,可以单继承,也可以多继承

接口默认方法:
- 格式: ```public default 返回值类型 方法名(参数列表) {}```
- 方法中默认参数的注意事项:
  - 默认方法不是抽象方法,不强制被重写,但是如果被重写,重写的时候就要去掉default关键字
  - public可以省略,default不能省略
  - 如果实现多个接口,多个接口存在相同的名字的默认方法,子类必须对该方法重写

### 内部类
定义: 在一个类的内部,在定义一个类

内部类的访问特点:
- 内部类可以直接访问外部类的成员,包括私有
- 外部类要访问内部类的成员,必须先创建对象

内部类的分类:
- 成员内部类
- 静态内部类
- 局部内部类
- 匿名内部类

编写成员内部类的注意点:
1. 成员内部类可以被一些修饰符修饰,比如private, 默认,protected,public
2. 在成员内部类里面,JDK16之前不能定义静态变量,16之后才能定义静态变量

获取成员内部对象的两种方式:
- 外部类编写方式,对外提供内部类对象
- 直接创建```例子:Outer.Inner oi = new Outer().new Inner()``` 

成员内部类如何和获取成员外部类:
通过```Outer.this.a```获取外部类变量

静态内部类:
- 静态内部类只能访问外部内部类中的静态变量和静态方法,如果想要访问非静态的需要创建对象.
- 创建内部类对象的格式:外部类名.内部类名 对象名 = new 外部类名.内部类名;
- 调用静态方法格式:外部类名.内部类名.方法名();

局部内部类:
1. 将内部类定义在方法里面就叫做局部内部类,类似于方法里的局部变量
2. 外界无法直接使用局部内部类,需要在方法内部创建对象并使用
3. 该类可以直接访问外部类成员,也可以访问方法内的局部变量

匿名内部类:
隐藏了名字的内部类,可以写在成员位置,也可以写在局部位置
```
new 类/接口() {
  重写的方法
}
```
细节:包含继承和实现,方法重写.创建对象
使用场景:
- 当方法的参数是接口或者类时,以接口为例,可以传递这个接口实现类对象,如果实现类只使用一次,,就可以用匿名内部类简化代码;